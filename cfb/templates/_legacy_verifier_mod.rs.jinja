{%- if mod.has_definitions() %}
  {%- for name, object in mod.objects.items() %}
    {%- if not object.IsStruct() %}

impl<'a> Verify for reader::{{ name }}<'a> {
    fn verify(&self) -> Result {
        let tab = self._tab;
        let buf = tab.buf;
        let buf_len = buf.len();

        if tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
            return Err(Error::OutOfBounds);
        }

        let vtab_loc = {
            let soffset_slice = &buf[tab.loc..tab.loc + flatbuffers::SIZE_SOFFSET];
            let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
            (tab.loc as flatbuffers::SOffsetT - soffset) as usize
        };
        if vtab_loc + flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET > buf_len {
            return Err(Error::OutOfBounds);
        }

        let vtab = tab.vtable();
        if vtab_loc + vtab.num_bytes() > buf_len {
            return Err(Error::OutOfBounds);
        }
        if tab.loc + vtab.object_inline_num_bytes() > buf_len {
            return Err(Error::OutOfBounds);
        }

        Ok(())
    }
}
    {%- endif %}
  {%- endfor %}
{%- endif %}

{%- for name, mod in mod.children.items() %}
  {%- set mod_content %}
    {%- include "_legacy_verifier_mod.rs.jinja" %}
  {%- endset %}
pub mod {{ name }} {
    #![allow(unused_imports)]

    use super::reader::{{ name }} as reader;
    pub use super::{Error, Result, Verify};
    use flatbuffers;
    {{- mod_content | indent }}
}
{%- endfor %}
