// automatically generated by the FlatBuffers compiler, do not modify


pub mod example {
  #![allow(dead_code)]
  #![allow(unused_imports)]

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(i16)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum Language {
  Rust = 0,
  Python = 1,

}

const ENUM_MIN_LANGUAGE: i16 = 0;
const ENUM_MAX_LANGUAGE: i16 = 1;

impl<'a> flatbuffers::Follow<'a> for Language {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Language {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i16::to_le(self as i16);
    let p = &n as *const i16 as *const Language;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i16::from_le(self as i16);
    let p = &n as *const i16 as *const Language;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Language {
    type Output = Language;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Language>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_LANGUAGE:[Language; 2] = [
  Language::Rust,
  Language::Python
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_LANGUAGE:[&'static str; 2] = [
    "Rust",
    "Python"
];

pub fn enum_name_language(e: Language) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_LANGUAGE[index]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum CodeOption {
  NONE = 0,
  Code = 1,

}

const ENUM_MIN_CODE_OPTION: u8 = 0;
const ENUM_MAX_CODE_OPTION: u8 = 1;

impl<'a> flatbuffers::Follow<'a> for CodeOption {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for CodeOption {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const CodeOption;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const CodeOption;
    unsafe { *p }
  }
}

impl flatbuffers::Push for CodeOption {
    type Output = CodeOption;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<CodeOption>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_CODE_OPTION:[CodeOption; 2] = [
  CodeOption::NONE,
  CodeOption::Code
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_CODE_OPTION:[&'static str; 2] = [
    "NONE",
    "Code"
];

pub fn enum_name_code_option(e: CodeOption) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_CODE_OPTION[index]
}

pub struct CodeOptionUnionTableOffset {}
// struct U256, aligned to 8
#[repr(C, align(8))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct U256 {
  byte_0_: u8,
  byte_1_: u8,
  byte_2_: u8,
  byte_3_: u8,
  byte_4_: u8,
  byte_5_: u8,
  byte_6_: u8,
  byte_7_: u8,
  byte_8_: u8,
  byte_9_: u8,
  byte_10_: u8,
  byte_11_: u8,
  byte_12_: u8,
  byte_13_: u8,
  byte_14_: u8,
  byte_15_: u8,
  byte_16_: u8,
  byte_17_: u8,
  byte_18_: u8,
  byte_19_: u8,
  byte_20_: u8,
  byte_21_: u8,
  byte_22_: u8,
  byte_23_: u8,
  byte_24_: u8,
  byte_25_: u8,
  byte_26_: u8,
  byte_27_: u8,
  byte_28_: u8,
  byte_29_: u8,
  byte_30_: u8,
  byte_31_: u8,
} // pub struct U256
impl flatbuffers::SafeSliceAccess for U256 {}
impl<'a> flatbuffers::Follow<'a> for U256 {
  type Inner = &'a U256;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a U256>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a U256 {
  type Inner = &'a U256;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<U256>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for U256 {
    type Output = U256;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const U256 as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b U256 {
    type Output = U256;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const U256 as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl U256 {
  pub fn new<'a>(_byte_0: u8, _byte_1: u8, _byte_2: u8, _byte_3: u8, _byte_4: u8, _byte_5: u8, _byte_6: u8, _byte_7: u8, _byte_8: u8, _byte_9: u8, _byte_10: u8, _byte_11: u8, _byte_12: u8, _byte_13: u8, _byte_14: u8, _byte_15: u8, _byte_16: u8, _byte_17: u8, _byte_18: u8, _byte_19: u8, _byte_20: u8, _byte_21: u8, _byte_22: u8, _byte_23: u8, _byte_24: u8, _byte_25: u8, _byte_26: u8, _byte_27: u8, _byte_28: u8, _byte_29: u8, _byte_30: u8, _byte_31: u8) -> Self {
    U256 {
      byte_0_: _byte_0.to_little_endian(),
      byte_1_: _byte_1.to_little_endian(),
      byte_2_: _byte_2.to_little_endian(),
      byte_3_: _byte_3.to_little_endian(),
      byte_4_: _byte_4.to_little_endian(),
      byte_5_: _byte_5.to_little_endian(),
      byte_6_: _byte_6.to_little_endian(),
      byte_7_: _byte_7.to_little_endian(),
      byte_8_: _byte_8.to_little_endian(),
      byte_9_: _byte_9.to_little_endian(),
      byte_10_: _byte_10.to_little_endian(),
      byte_11_: _byte_11.to_little_endian(),
      byte_12_: _byte_12.to_little_endian(),
      byte_13_: _byte_13.to_little_endian(),
      byte_14_: _byte_14.to_little_endian(),
      byte_15_: _byte_15.to_little_endian(),
      byte_16_: _byte_16.to_little_endian(),
      byte_17_: _byte_17.to_little_endian(),
      byte_18_: _byte_18.to_little_endian(),
      byte_19_: _byte_19.to_little_endian(),
      byte_20_: _byte_20.to_little_endian(),
      byte_21_: _byte_21.to_little_endian(),
      byte_22_: _byte_22.to_little_endian(),
      byte_23_: _byte_23.to_little_endian(),
      byte_24_: _byte_24.to_little_endian(),
      byte_25_: _byte_25.to_little_endian(),
      byte_26_: _byte_26.to_little_endian(),
      byte_27_: _byte_27.to_little_endian(),
      byte_28_: _byte_28.to_little_endian(),
      byte_29_: _byte_29.to_little_endian(),
      byte_30_: _byte_30.to_little_endian(),
      byte_31_: _byte_31.to_little_endian(),

    }
  }
  pub fn byte_0<'a>(&'a self) -> u8 {
    self.byte_0_.from_little_endian()
  }
  pub fn byte_1<'a>(&'a self) -> u8 {
    self.byte_1_.from_little_endian()
  }
  pub fn byte_2<'a>(&'a self) -> u8 {
    self.byte_2_.from_little_endian()
  }
  pub fn byte_3<'a>(&'a self) -> u8 {
    self.byte_3_.from_little_endian()
  }
  pub fn byte_4<'a>(&'a self) -> u8 {
    self.byte_4_.from_little_endian()
  }
  pub fn byte_5<'a>(&'a self) -> u8 {
    self.byte_5_.from_little_endian()
  }
  pub fn byte_6<'a>(&'a self) -> u8 {
    self.byte_6_.from_little_endian()
  }
  pub fn byte_7<'a>(&'a self) -> u8 {
    self.byte_7_.from_little_endian()
  }
  pub fn byte_8<'a>(&'a self) -> u8 {
    self.byte_8_.from_little_endian()
  }
  pub fn byte_9<'a>(&'a self) -> u8 {
    self.byte_9_.from_little_endian()
  }
  pub fn byte_10<'a>(&'a self) -> u8 {
    self.byte_10_.from_little_endian()
  }
  pub fn byte_11<'a>(&'a self) -> u8 {
    self.byte_11_.from_little_endian()
  }
  pub fn byte_12<'a>(&'a self) -> u8 {
    self.byte_12_.from_little_endian()
  }
  pub fn byte_13<'a>(&'a self) -> u8 {
    self.byte_13_.from_little_endian()
  }
  pub fn byte_14<'a>(&'a self) -> u8 {
    self.byte_14_.from_little_endian()
  }
  pub fn byte_15<'a>(&'a self) -> u8 {
    self.byte_15_.from_little_endian()
  }
  pub fn byte_16<'a>(&'a self) -> u8 {
    self.byte_16_.from_little_endian()
  }
  pub fn byte_17<'a>(&'a self) -> u8 {
    self.byte_17_.from_little_endian()
  }
  pub fn byte_18<'a>(&'a self) -> u8 {
    self.byte_18_.from_little_endian()
  }
  pub fn byte_19<'a>(&'a self) -> u8 {
    self.byte_19_.from_little_endian()
  }
  pub fn byte_20<'a>(&'a self) -> u8 {
    self.byte_20_.from_little_endian()
  }
  pub fn byte_21<'a>(&'a self) -> u8 {
    self.byte_21_.from_little_endian()
  }
  pub fn byte_22<'a>(&'a self) -> u8 {
    self.byte_22_.from_little_endian()
  }
  pub fn byte_23<'a>(&'a self) -> u8 {
    self.byte_23_.from_little_endian()
  }
  pub fn byte_24<'a>(&'a self) -> u8 {
    self.byte_24_.from_little_endian()
  }
  pub fn byte_25<'a>(&'a self) -> u8 {
    self.byte_25_.from_little_endian()
  }
  pub fn byte_26<'a>(&'a self) -> u8 {
    self.byte_26_.from_little_endian()
  }
  pub fn byte_27<'a>(&'a self) -> u8 {
    self.byte_27_.from_little_endian()
  }
  pub fn byte_28<'a>(&'a self) -> u8 {
    self.byte_28_.from_little_endian()
  }
  pub fn byte_29<'a>(&'a self) -> u8 {
    self.byte_29_.from_little_endian()
  }
  pub fn byte_30<'a>(&'a self) -> u8 {
    self.byte_30_.from_little_endian()
  }
  pub fn byte_31<'a>(&'a self) -> u8 {
    self.byte_31_.from_little_endian()
  }
}

// struct Scalars, aligned to 8
#[repr(C, align(8))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Scalars {
  a_byte_: i8,
  a_ubyte_: u8,
  a_bool_: bool,
  padding0__: u8,
  a_short_: i16,
  a_ushort_: u16,
  a_int_: i32,
  a_uint_: u32,
  a_float_: f32,
  padding1__: u32,
  a_long_: i64,
  a_ulong_: u64,
  a_double_: f64,
} // pub struct Scalars
impl flatbuffers::SafeSliceAccess for Scalars {}
impl<'a> flatbuffers::Follow<'a> for Scalars {
  type Inner = &'a Scalars;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Scalars>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Scalars {
  type Inner = &'a Scalars;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Scalars>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Scalars {
    type Output = Scalars;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Scalars as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Scalars {
    type Output = Scalars;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Scalars as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Scalars {
  pub fn new<'a>(_a_byte: i8, _a_ubyte: u8, _a_bool: bool, _a_short: i16, _a_ushort: u16, _a_int: i32, _a_uint: u32, _a_float: f32, _a_long: i64, _a_ulong: u64, _a_double: f64) -> Self {
    Scalars {
      a_byte_: _a_byte.to_little_endian(),
      a_ubyte_: _a_ubyte.to_little_endian(),
      a_bool_: _a_bool.to_little_endian(),
      a_short_: _a_short.to_little_endian(),
      a_ushort_: _a_ushort.to_little_endian(),
      a_int_: _a_int.to_little_endian(),
      a_uint_: _a_uint.to_little_endian(),
      a_float_: _a_float.to_little_endian(),
      a_long_: _a_long.to_little_endian(),
      a_ulong_: _a_ulong.to_little_endian(),
      a_double_: _a_double.to_little_endian(),

      padding0__: 0,
      padding1__: 0,
    }
  }
  pub fn a_byte<'a>(&'a self) -> i8 {
    self.a_byte_.from_little_endian()
  }
  pub fn a_ubyte<'a>(&'a self) -> u8 {
    self.a_ubyte_.from_little_endian()
  }
  pub fn a_bool<'a>(&'a self) -> bool {
    self.a_bool_.from_little_endian()
  }
  pub fn a_short<'a>(&'a self) -> i16 {
    self.a_short_.from_little_endian()
  }
  pub fn a_ushort<'a>(&'a self) -> u16 {
    self.a_ushort_.from_little_endian()
  }
  pub fn a_int<'a>(&'a self) -> i32 {
    self.a_int_.from_little_endian()
  }
  pub fn a_uint<'a>(&'a self) -> u32 {
    self.a_uint_.from_little_endian()
  }
  pub fn a_float<'a>(&'a self) -> f32 {
    self.a_float_.from_little_endian()
  }
  pub fn a_long<'a>(&'a self) -> i64 {
    self.a_long_.from_little_endian()
  }
  pub fn a_ulong<'a>(&'a self) -> u64 {
    self.a_ulong_.from_little_endian()
  }
  pub fn a_double<'a>(&'a self) -> f64 {
    self.a_double_.from_little_endian()
  }
}

pub enum ChildExampleOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ChildExample<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ChildExample<'a> {
    type Inner = ChildExample<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ChildExample<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ChildExample {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ChildExampleArgs<'args>) -> flatbuffers::WIPOffset<ChildExample<'bldr>> {
      let mut builder = ChildExampleBuilder::new(_fbb);
      if let Some(x) = args.buffer { builder.add_buffer(x); }
      builder.finish()
    }

    pub const VT_BUFFER: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn buffer(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ChildExample::VT_BUFFER, None).map(|v| v.safe_slice())
  }
  pub fn buffer_nested_flatbuffer(&'a self) ->  Option<ChildExample<'a>> {
     match self.buffer() {
         None => { None }
         Some(data) => {
             use self::flatbuffers::Follow;
             Some(<flatbuffers::ForwardsUOffset<ChildExample<'a>>>::follow(data, 0))
         },
     }
  }
}

pub struct ChildExampleArgs<'a> {
    pub buffer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for ChildExampleArgs<'a> {
    #[inline]
    fn default() -> Self {
        ChildExampleArgs {
            buffer: None,
        }
    }
}
pub struct ChildExampleBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ChildExampleBuilder<'a, 'b> {
  #[inline]
  pub fn add_buffer(&mut self, buffer: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ChildExample::VT_BUFFER, buffer);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ChildExampleBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ChildExampleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ChildExample<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ExampleOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Example<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Example<'a> {
    type Inner = Example<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Example<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Example {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ExampleArgs<'args>) -> flatbuffers::WIPOffset<Example<'bldr>> {
      let mut builder = ExampleBuilder::new(_fbb);
      builder.add_lines(args.lines);
      if let Some(x) = args.children { builder.add_children(x); }
      if let Some(x) = args.blocks { builder.add_blocks(x); }
      if let Some(x) = args.scalars { builder.add_scalars(x); }
      if let Some(x) = args.hash { builder.add_hash(x); }
      builder.add_version(args.version);
      builder.add_language(args.language);
      builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_HASH: flatbuffers::VOffsetT = 6;
    pub const VT_LANGUAGE: flatbuffers::VOffsetT = 8;
    pub const VT_SCALARS: flatbuffers::VOffsetT = 10;
    pub const VT_BLOCKS: flatbuffers::VOffsetT = 14;
    pub const VT_CHILDREN: flatbuffers::VOffsetT = 16;
    pub const VT_LINES: flatbuffers::VOffsetT = 18;

  #[inline]
  pub fn version(&self) -> u32 {
    self._tab.get::<u32>(Example::VT_VERSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn hash(&self) -> Option<&'a U256> {
    self._tab.get::<U256>(Example::VT_HASH, None)
  }
  #[inline]
  pub fn language(&self) -> Language {
    self._tab.get::<Language>(Example::VT_LANGUAGE, Some(Language::Rust)).unwrap()
  }
  #[inline]
  pub fn scalars(&self) -> Option<&'a Scalars> {
    self._tab.get::<Scalars>(Example::VT_SCALARS, None)
  }
  #[inline]
  pub fn blocks(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Block<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Block<'a>>>>>(Example::VT_BLOCKS, None)
  }
  #[inline]
  pub fn children(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<ChildExample<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<ChildExample<'a>>>>>(Example::VT_CHILDREN, None)
  }
  #[inline]
  pub fn lines(&self) -> u32 {
    self._tab.get::<u32>(Example::VT_LINES, Some(0)).unwrap()
  }
}

pub struct ExampleArgs<'a> {
    pub version: u32,
    pub hash: Option<&'a  U256>,
    pub language: Language,
    pub scalars: Option<&'a  Scalars>,
    pub blocks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Block<'a >>>>>,
    pub children: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<ChildExample<'a >>>>>,
    pub lines: u32,
}
impl<'a> Default for ExampleArgs<'a> {
    #[inline]
    fn default() -> Self {
        ExampleArgs {
            version: 0,
            hash: None,
            language: Language::Rust,
            scalars: None,
            blocks: None,
            children: None,
            lines: 0,
        }
    }
}
pub struct ExampleBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExampleBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: u32) {
    self.fbb_.push_slot::<u32>(Example::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_hash(&mut self, hash: &'b  U256) {
    self.fbb_.push_slot_always::<&U256>(Example::VT_HASH, hash);
  }
  #[inline]
  pub fn add_language(&mut self, language: Language) {
    self.fbb_.push_slot::<Language>(Example::VT_LANGUAGE, language, Language::Rust);
  }
  #[inline]
  pub fn add_scalars(&mut self, scalars: &'b  Scalars) {
    self.fbb_.push_slot_always::<&Scalars>(Example::VT_SCALARS, scalars);
  }
  #[inline]
  pub fn add_blocks(&mut self, blocks: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Block<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Example::VT_BLOCKS, blocks);
  }
  #[inline]
  pub fn add_children(&mut self, children: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ChildExample<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Example::VT_CHILDREN, children);
  }
  #[inline]
  pub fn add_lines(&mut self, lines: u32) {
    self.fbb_.push_slot::<u32>(Example::VT_LINES, lines, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExampleBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ExampleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Example<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CodeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Code<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Code<'a> {
    type Inner = Code<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Code<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Code {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CodeArgs<'args>) -> flatbuffers::WIPOffset<Code<'bldr>> {
      let mut builder = CodeBuilder::new(_fbb);
      if let Some(x) = args.bytes { builder.add_bytes(x); }
      builder.finish()
    }

    pub const VT_BYTES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn bytes(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Code::VT_BYTES, None).map(|v| v.safe_slice())
  }
}

pub struct CodeArgs<'a> {
    pub bytes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for CodeArgs<'a> {
    #[inline]
    fn default() -> Self {
        CodeArgs {
            bytes: None,
        }
    }
}
pub struct CodeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CodeBuilder<'a, 'b> {
  #[inline]
  pub fn add_bytes(&mut self, bytes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Code::VT_BYTES, bytes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CodeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CodeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Code<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum AuthorOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Author<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Author<'a> {
    type Inner = Author<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Author<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Author {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AuthorArgs<'args>) -> flatbuffers::WIPOffset<Author<'bldr>> {
      let mut builder = AuthorBuilder::new(_fbb);
      builder.add_birth(args.birth);
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_BIRTH: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Author::VT_NAME, None)
  }
  #[inline]
  pub fn birth(&self) -> u32 {
    self._tab.get::<u32>(Author::VT_BIRTH, Some(0)).unwrap()
  }
}

pub struct AuthorArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub birth: u32,
}
impl<'a> Default for AuthorArgs<'a> {
    #[inline]
    fn default() -> Self {
        AuthorArgs {
            name: None,
            birth: 0,
        }
    }
}
pub struct AuthorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AuthorBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Author::VT_NAME, name);
  }
  #[inline]
  pub fn add_birth(&mut self, birth: u32) {
    self.fbb_.push_slot::<u32>(Author::VT_BIRTH, birth, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AuthorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AuthorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Author<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BlockOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Block<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Block<'a> {
    type Inner = Block<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Block<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Block {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BlockArgs<'args>) -> flatbuffers::WIPOffset<Block<'bldr>> {
      let mut builder = BlockBuilder::new(_fbb);
      if let Some(x) = args.code { builder.add_code(x); }
      if let Some(x) = args.author { builder.add_author(x); }
      builder.add_code_type(args.code_type);
      builder.finish()
    }

    pub const VT_AUTHOR: flatbuffers::VOffsetT = 4;
    pub const VT_CODE_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_CODE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn author(&self) -> Option<Author<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Author<'a>>>(Block::VT_AUTHOR, None)
  }
  #[inline]
  pub fn code_type(&self) -> CodeOption {
    self._tab.get::<CodeOption>(Block::VT_CODE_TYPE, Some(CodeOption::NONE)).unwrap()
  }
  #[inline]
  pub fn code(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Block::VT_CODE, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn code_as_code(&'a self) -> Option<Code> {
    if self.code_type() == CodeOption::Code {
      self.code().map(|u| Code::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct BlockArgs<'a> {
    pub author: Option<flatbuffers::WIPOffset<Author<'a >>>,
    pub code_type: CodeOption,
    pub code: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for BlockArgs<'a> {
    #[inline]
    fn default() -> Self {
        BlockArgs {
            author: None,
            code_type: CodeOption::NONE,
            code: None,
        }
    }
}
pub struct BlockBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockBuilder<'a, 'b> {
  #[inline]
  pub fn add_author(&mut self, author: flatbuffers::WIPOffset<Author<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Author>>(Block::VT_AUTHOR, author);
  }
  #[inline]
  pub fn add_code_type(&mut self, code_type: CodeOption) {
    self.fbb_.push_slot::<CodeOption>(Block::VT_CODE_TYPE, code_type, CodeOption::NONE);
  }
  #[inline]
  pub fn add_code(&mut self, code: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Block::VT_CODE, code);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Block<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_example<'a>(buf: &'a [u8]) -> Example<'a> {
  flatbuffers::get_root::<Example<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_example<'a>(buf: &'a [u8]) -> Example<'a> {
  flatbuffers::get_size_prefixed_root::<Example<'a>>(buf)
}

#[inline]
pub fn finish_example_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Example<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_example_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Example<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod example

