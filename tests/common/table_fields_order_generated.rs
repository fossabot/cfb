// automatically generated by the FlatBuffers compiler, do not modify


#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum Result {
  NONE = 0,
  Ok = 1,
  Err = 2,

}

const ENUM_MIN_RESULT: u8 = 0;
const ENUM_MAX_RESULT: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for Result {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Result {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Result;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Result;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Result {
    type Output = Result;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Result>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_RESULT:[Result; 3] = [
  Result::NONE,
  Result::Ok,
  Result::Err
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_RESULT:[&'static str; 3] = [
    "NONE",
    "Ok",
    "Err"
];

pub fn enum_name_result(e: Result) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_RESULT[index]
}

pub struct ResultUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum Color {
  Red = 0,
  Green = 1,
  Blue = 2,

}

const ENUM_MIN_COLOR: i8 = 0;
const ENUM_MAX_COLOR: i8 = 2;

impl<'a> flatbuffers::Follow<'a> for Color {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Color {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const Color;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const Color;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Color {
    type Output = Color;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Color>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_COLOR:[Color; 3] = [
  Color::Red,
  Color::Green,
  Color::Blue
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_COLOR:[&'static str; 3] = [
    "Red",
    "Green",
    "Blue"
];

pub fn enum_name_color(e: Color) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_COLOR[index]
}

// struct Complex, aligned to 8
#[repr(C, align(8))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Complex {
  a_: u64,
  b_: u64,
} // pub struct Complex
impl flatbuffers::SafeSliceAccess for Complex {}
impl<'a> flatbuffers::Follow<'a> for Complex {
  type Inner = &'a Complex;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Complex>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Complex {
  type Inner = &'a Complex;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Complex>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Complex {
    type Output = Complex;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Complex as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Complex {
    type Output = Complex;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Complex as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Complex {
  pub fn new<'a>(_a: u64, _b: u64) -> Self {
    Complex {
      a_: _a.to_little_endian(),
      b_: _b.to_little_endian(),

    }
  }
  pub fn a<'a>(&'a self) -> u64 {
    self.a_.from_little_endian()
  }
  pub fn b<'a>(&'a self) -> u64 {
    self.b_.from_little_endian()
  }
}

pub enum OkOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Ok<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Ok<'a> {
    type Inner = Ok<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Ok<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Ok {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OkArgs) -> flatbuffers::WIPOffset<Ok<'bldr>> {
      let mut builder = OkBuilder::new(_fbb);
      builder.add_value(args.value);
      builder.finish()
    }

    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn value(&self) -> u32 {
    self._tab.get::<u32>(Ok::VT_VALUE, Some(0)).unwrap()
  }
}

pub struct OkArgs {
    pub value: u32,
}
impl<'a> Default for OkArgs {
    #[inline]
    fn default() -> Self {
        OkArgs {
            value: 0,
        }
    }
}
pub struct OkBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OkBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: u32) {
    self.fbb_.push_slot::<u32>(Ok::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OkBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OkBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Ok<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ErrOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Err<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Err<'a> {
    type Inner = Err<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Err<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Err {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ErrArgs<'args>) -> flatbuffers::WIPOffset<Err<'bldr>> {
      let mut builder = ErrBuilder::new(_fbb);
      if let Some(x) = args.reason { builder.add_reason(x); }
      builder.finish()
    }

    pub const VT_REASON: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn reason(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Err::VT_REASON, None)
  }
}

pub struct ErrArgs<'a> {
    pub reason: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for ErrArgs<'a> {
    #[inline]
    fn default() -> Self {
        ErrArgs {
            reason: None,
        }
    }
}
pub struct ErrBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ErrBuilder<'a, 'b> {
  #[inline]
  pub fn add_reason(&mut self, reason: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Err::VT_REASON, reason);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ErrBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ErrBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Err<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum TOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct T<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for T<'a> {
    type Inner = T<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> T<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        T {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TArgs<'args>) -> flatbuffers::WIPOffset<T<'bldr>> {
      let mut builder = TBuilder::new(_fbb);
      builder.add_a_uint64(args.a_uint64);
      if let Some(x) = args.uint16_array { builder.add_uint16_array(x); }
      if let Some(x) = args.result { builder.add_result(x); }
      builder.add_a_uint32(args.a_uint32);
      if let Some(x) = args.complex { builder.add_complex(x); }
      builder.add_color(args.color);
      builder.add_result_type(args.result_type);
      builder.add_a_ubyte(args.a_ubyte);
      builder.finish()
    }

    pub const VT_A_UBYTE: flatbuffers::VOffsetT = 4;
    pub const VT_COMPLEX: flatbuffers::VOffsetT = 6;
    pub const VT_A_UINT32: flatbuffers::VOffsetT = 8;
    pub const VT_RESULT_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_RESULT: flatbuffers::VOffsetT = 12;
    pub const VT_A_UINT64: flatbuffers::VOffsetT = 14;
    pub const VT_UINT16_ARRAY: flatbuffers::VOffsetT = 16;
    pub const VT_COLOR: flatbuffers::VOffsetT = 18;

  #[inline]
  pub fn a_ubyte(&self) -> u8 {
    self._tab.get::<u8>(T::VT_A_UBYTE, Some(0)).unwrap()
  }
  #[inline]
  pub fn complex(&self) -> Option<&'a Complex> {
    self._tab.get::<Complex>(T::VT_COMPLEX, None)
  }
  #[inline]
  pub fn a_uint32(&self) -> u32 {
    self._tab.get::<u32>(T::VT_A_UINT32, Some(0)).unwrap()
  }
  #[inline]
  pub fn result_type(&self) -> Result {
    self._tab.get::<Result>(T::VT_RESULT_TYPE, Some(Result::NONE)).unwrap()
  }
  #[inline]
  pub fn result(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(T::VT_RESULT, None)
  }
  #[inline]
  pub fn a_uint64(&self) -> u64 {
    self._tab.get::<u64>(T::VT_A_UINT64, Some(0)).unwrap()
  }
  #[inline]
  pub fn uint16_array(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(T::VT_UINT16_ARRAY, None)
  }
  #[inline]
  pub fn color(&self) -> Color {
    self._tab.get::<Color>(T::VT_COLOR, Some(Color::Red)).unwrap()
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn result_as_ok(&'a self) -> Option<Ok> {
    if self.result_type() == Result::Ok {
      self.result().map(|u| Ok::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn result_as_err(&'a self) -> Option<Err> {
    if self.result_type() == Result::Err {
      self.result().map(|u| Err::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct TArgs<'a> {
    pub a_ubyte: u8,
    pub complex: Option<&'a  Complex>,
    pub a_uint32: u32,
    pub result_type: Result,
    pub result: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub a_uint64: u64,
    pub uint16_array: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u16>>>,
    pub color: Color,
}
impl<'a> Default for TArgs<'a> {
    #[inline]
    fn default() -> Self {
        TArgs {
            a_ubyte: 0,
            complex: None,
            a_uint32: 0,
            result_type: Result::NONE,
            result: None,
            a_uint64: 0,
            uint16_array: None,
            color: Color::Red,
        }
    }
}
pub struct TBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TBuilder<'a, 'b> {
  #[inline]
  pub fn add_a_ubyte(&mut self, a_ubyte: u8) {
    self.fbb_.push_slot::<u8>(T::VT_A_UBYTE, a_ubyte, 0);
  }
  #[inline]
  pub fn add_complex(&mut self, complex: &'b  Complex) {
    self.fbb_.push_slot_always::<&Complex>(T::VT_COMPLEX, complex);
  }
  #[inline]
  pub fn add_a_uint32(&mut self, a_uint32: u32) {
    self.fbb_.push_slot::<u32>(T::VT_A_UINT32, a_uint32, 0);
  }
  #[inline]
  pub fn add_result_type(&mut self, result_type: Result) {
    self.fbb_.push_slot::<Result>(T::VT_RESULT_TYPE, result_type, Result::NONE);
  }
  #[inline]
  pub fn add_result(&mut self, result: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(T::VT_RESULT, result);
  }
  #[inline]
  pub fn add_a_uint64(&mut self, a_uint64: u64) {
    self.fbb_.push_slot::<u64>(T::VT_A_UINT64, a_uint64, 0);
  }
  #[inline]
  pub fn add_uint16_array(&mut self, uint16_array: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(T::VT_UINT16_ARRAY, uint16_array);
  }
  #[inline]
  pub fn add_color(&mut self, color: Color) {
    self.fbb_.push_slot::<Color>(T::VT_COLOR, color, Color::Red);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<T<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_t<'a>(buf: &'a [u8]) -> T<'a> {
  flatbuffers::get_root::<T<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_t<'a>(buf: &'a [u8]) -> T<'a> {
  flatbuffers::get_size_prefixed_root::<T<'a>>(buf)
}

#[inline]
pub fn finish_t_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<T<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_t_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<T<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
